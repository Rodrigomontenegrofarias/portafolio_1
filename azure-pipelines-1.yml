trigger:
  branches:
    include:
      - main
#  tags:
#    include:
#      - V*

# Trigger para Pull Requests hacia main
pr:
- main

pool:
  name: Default

variables:
  buildDir: 'build'
  tagToUse: ''

stages:
- stage: Build_And_Deploy
  jobs:
  - job: GetLatestTag
    displayName: 'Obtener último tag'
    steps:
    - checkout: self
      fetchDepth: 0  # Obtiene todo el historial y tags
      
    - script: |
        # Obtener el último tag ordenado por fecha
        LATEST_TAG=$(git tag --sort=-committerdate | head -n 1)
        
        if [ -z "$LATEST_TAG" ]; then
          echo "##vso[task.logissue type=error]No se encontraron tags en el repositorio."
          exit 1
        fi
        
        echo "Último tag disponible: $LATEST_TAG"
        
        # Establecer variable para el siguiente job
        echo "##vso[task.setvariable variable=tagToUse;isOutput=true]$LATEST_TAG"
      displayName: 'Obtener último tag disponible'
      name: tagSelection

  - job: BuildAndDeploy
    dependsOn: GetLatestTag
    variables:
      deployTag: $[ dependencies.GetLatestTag.outputs['tagSelection.tagToUse'] ]
    steps:
    - checkout: self
      fetchDepth: 0
      clean: true
      
    - script: |
        # Verificar el tag que vamos a usar
        echo "Tag seleccionado para despliegue: $(deployTag)"
        
        # Verificar que el tag existe
        if ! git rev-parse "$(deployTag)" >/dev/null 2>&1; then
          echo "##vso[task.logissue type=error]El tag $(deployTag) no existe en el repositorio."
          echo "##[error]Tags disponibles:"
          git tag -l
          exit 1
        fi
        
        # Hacer checkout al tag seleccionado
        echo "Preparando despliegue del tag: $(deployTag)"
        git checkout $(deployTag)
        
        # Verificar que estamos en el tag correcto
        CURRENT_COMMIT=$(git rev-parse HEAD)
        TAG_COMMIT=$(git rev-parse $(deployTag))
        
        if [ "$CURRENT_COMMIT" != "$TAG_COMMIT" ]; then
          echo "##[error]No se pudo hacer checkout al tag $(deployTag)."
          exit 1
        fi
        
        echo "Checkout exitoso al tag $(deployTag) (commit: $CURRENT_COMMIT)"
      displayName: 'Checkout al tag seleccionado'
      
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Install Node.js'

    # Crear archivos necesarios para la versión
    - script: |
        echo "Configurando archivos para la versión: $(deployTag)"
        
        # Crear directorios si no existen
        mkdir -p src
        mkdir -p public
        mkdir -p scripts
        
        # 1. Crear archivo AppVersion.js
        cat > src/AppVersion.js << 'EOL'
// AppVersion.js - Define la versión de la aplicación
import latestTag from './latestTag.txt';

// Define APP_VERSION globalmente para que esté disponible en todo el código
window.APP_VERSION = latestTag || process.env.REACT_APP_VERSION || 'Desarrollo';

// Para compatibilidad con el código existente, también lo definimos como una variable
// eslint-disable-next-line
var APP_VERSION = window.APP_VERSION;

console.log('Versión de la aplicación:', APP_VERSION);

export default APP_VERSION;
EOL
        
        # 2. Crear archivo latestTag.txt
        echo "$(deployTag)" > src/latestTag.txt
        
        # 3. Crear archivo env.js
        cat > public/env.js << EOL
// Archivo generado por el pipeline
window.APP_VERSION = "$(deployTag)";
console.log("Versión cargada desde env.js:", window.APP_VERSION);
EOL
        
        # 4. Crear archivo .env
        echo "REACT_APP_VERSION=$(deployTag)" > .env
        
        echo "Archivos de configuración creados."
      displayName: 'Crear archivos de configuración'

    # Modificar App.js para importar AppVersion si es necesario
    - script: |
        echo "Verificando App.js..."
        
        if [ -f "src/App.js" ]; then
          # Verificar si ya importa AppVersion
          if ! grep -q "import './AppVersion'" src/App.js; then
            echo "Modificando App.js para importar AppVersion..."
            
            # Crear copia de respaldo
            cp src/App.js src/App.js.bak
            
            # Buscar la primera línea de importación para agregar después de ella
            FIRST_IMPORT_LINE=$(grep -n "import " src/App.js | head -1 | cut -d: -f1)
            
            if [ -n "$FIRST_IMPORT_LINE" ]; then
              # Insertar después de la última línea de importación
              LAST_IMPORT_LINE=$(grep -n "import " src/App.js | tail -1 | cut -d: -f1)
              
              # Crear archivo temporal
              head -n $LAST_IMPORT_LINE src/App.js > src/App.js.tmp
              echo "import './AppVersion'; // Define APP_VERSION globalmente" >> src/App.js.tmp
              tail -n +$((LAST_IMPORT_LINE+1)) src/App.js >> src/App.js.tmp
              
              # Reemplazar el original
              mv src/App.js.tmp src/App.js
              
              echo "App.js modificado para importar AppVersion."
            else
              echo "No se pudo encontrar líneas de importación en App.js."
            fi
          else
            echo "App.js ya importa AppVersion."
          fi
        else
          echo "##[warning]src/App.js no existe."
        fi
      displayName: 'Modificar App.js si es necesario'
      continueOnError: true

    # Instalar dependencias
    - script: |
        npm install
      displayName: 'npm install'
      
    # Construir la aplicación
    - script: |
        echo "Construyendo la aplicación con la versión $(deployTag)..."
        REACT_APP_VERSION="$(deployTag)" npm run build
      displayName: 'npm run build'
      env:
        REACT_APP_VERSION: $(deployTag)
        REACT_APP_EMAILJS_PUBLIC_KEY: $(REACT_APP_EMAILJS_PUBLIC_KEY)
        REACT_APP_EMAILJS_SERVICE_ID: $(REACT_APP_EMAILJS_SERVICE_ID)
        REACT_APP_EMAILJS_TEMPLATE_ID: $(REACT_APP_EMAILJS_TEMPLATE_ID)

    # Confirmar que env.js está en build con el contenido correcto
    - script: |
        echo "Asegurando que env.js está en la carpeta build..."
        
        # Confirmar que env.js está en build y tiene el contenido correcto
        cat > build/env.js << EOL
// Archivo generado por el pipeline
window.APP_VERSION = "$(deployTag)";
console.log("Versión cargada desde env.js:", window.APP_VERSION);
EOL
        
        echo "env.js copiado a la carpeta build."
        echo "Contenido de la carpeta build:"
        ls -la build/
      displayName: 'Copiar env.js a build'

    # Archivar build
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/$(buildDir)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/build.zip'
        replaceExistingArchive: true
      displayName: 'Archive React build folder'

    # Publicar artefacto
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/build.zip'
        ArtifactName: 'drop'
        publishLocation: 'Container'
      displayName: 'Publish build artifact'

    # Desplegar a Netlify
    - script: |
        # Añadir información del tag al título del despliegue
        DEPLOY_TITLE="Deploy $(deployTag) from Azure DevOps"
        
        echo "Desplegando a Netlify con título: $DEPLOY_TITLE"
        
        # Desplegar usando la API de Netlify
        curl -X POST https://api.netlify.com/api/v1/sites/$(NETLIFY_SITE_ID)/deploys \
        -H "Authorization: Bearer $(NETLIFY_AUTH_TOKEN)" \
        -F "file=@$(Build.ArtifactStagingDirectory)/build.zip" \
        -F "title=$DEPLOY_TITLE"
      displayName: 'Deploy to Netlify'
      env:
        NETLIFY_AUTH_TOKEN: $(NETLIFY_AUTH_TOKEN)
        NETLIFY_SITE_ID: $(NETLIFY_SITE_ID)