trigger:
  branches:
    include:
      - main  # Excluye todas las ramas
#  tags:
#    include:
#      - V*

# Trigger para Pull Requests hacia main
pr:
- main

pool:
  name: Default

variables:
  buildDir: 'build'
  tagToUse: ''

stages:
- stage: Build_And_Deploy
  jobs:
  - job: GetLatestTag
    displayName: 'Obtener último tag'
    steps:
    - checkout: self
      fetchDepth: 0  # Obtiene todo el historial y tags
      
    - script: |
        # Obtener el último tag ordenado por fecha
        LATEST_TAG=$(git tag --sort=-committerdate | head -n 1)
        
        if [ -z "$LATEST_TAG" ]; then
          echo "##vso[task.logissue type=error]No se encontraron tags en el repositorio."
          exit 1
        fi
        
        echo "Último tag disponible: $LATEST_TAG"
        
        # Establecer variable para el siguiente job
        echo "##vso[task.setvariable variable=tagToUse;isOutput=true]$LATEST_TAG"
      displayName: 'Obtener último tag disponible'
      name: tagSelection

  - job: BuildAndDeploy
    dependsOn: GetLatestTag
    variables:
      deployTag: $[ dependencies.GetLatestTag.outputs['tagSelection.tagToUse'] ]
    steps:
    - checkout: self
      fetchDepth: 0
      clean: true
      
    - script: |
        # Verificar el tag que vamos a usar
        echo "Tag seleccionado para despliegue: $(deployTag)"
        
        # Verificar que el tag existe
        if ! git rev-parse "$(deployTag)" >/dev/null 2>&1; then
          echo "##vso[task.logissue type=error]El tag $(deployTag) no existe en el repositorio."
          echo "##[error]Tags disponibles:"
          git tag -l
          exit 1
        fi
        
        # Hacer checkout al tag seleccionado
        echo "Preparando despliegue del tag: $(deployTag)"
        git checkout $(deployTag)
        
        # Verificar que estamos en el tag correcto
        CURRENT_COMMIT=$(git rev-parse HEAD)
        TAG_COMMIT=$(git rev-parse $(deployTag))
        
        if [ "$CURRENT_COMMIT" != "$TAG_COMMIT" ]; then
          echo "##[error]No se pudo hacer checkout al tag $(deployTag)."
          exit 1
        fi
        
        echo "Checkout exitoso al tag $(deployTag) (commit: $CURRENT_COMMIT)"
      displayName: 'Checkout al tag seleccionado'
      
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Install Node.js'

    # Crear directorios necesarios si no existen
    - script: |
        mkdir -p public
        mkdir -p src
        mkdir -p scripts
      displayName: 'Crear directorios si no existen'

    # Crear archivos de configuración para exponer el tag a la aplicación React
    - script: |
        # Crear archivo .env
        echo "REACT_APP_VERSION=$(deployTag)" > .env
        
        # Crear carpeta scripts si no existe
        mkdir -p scripts
        
        # Crear script setTag.js
        cat > scripts/setTag.js << 'EOF'
const fs = require('fs');
const path = require('path');

// Obtener la versión de la variable de entorno
let appVersion = process.env.REACT_APP_VERSION;

// Si no existe, intentar obtenerla del archivo .env
if (!appVersion) {
  try {
    const envFilePath = path.resolve(process.cwd(), '.env');
    if (fs.existsSync(envFilePath)) {
      const envContent = fs.readFileSync(envFilePath, 'utf8');
      const versionMatch = envContent.match(/REACT_APP_VERSION=(.+)/);
      if (versionMatch && versionMatch[1]) {
        appVersion = versionMatch[1];
      }
    }
  } catch (error) {
    console.warn('Error al leer archivo .env:', error);
  }
}

// Si todavía no existe, usar valor por defecto
if (!appVersion) {
  appVersion = 'v0.0.0';
}

console.log(`Configurando versión de aplicación: ${appVersion}`);

// Crear archivo env.js en la carpeta public
const envJsPath = path.resolve(process.cwd(), 'public', 'env.js');
const envJsContent = `// Archivo generado automáticamente por setTag.js
window.APP_VERSION = "${appVersion}";
console.log("Versión de aplicación cargada:", window.APP_VERSION);
`;

// Escribir el archivo
fs.writeFileSync(envJsPath, envJsContent);
console.log(`Archivo env.js creado en: ${envJsPath}`);

// También crear un archivo latestTag.txt para tener la versión disponible de otra manera
try {
  const tagPath = path.resolve(process.cwd(), 'src', 'latestTag.txt');
  fs.writeFileSync(tagPath, appVersion);
  console.log(`Archivo latestTag.txt creado en: ${tagPath}`);
} catch (error) {
  console.error('Error al crear archivo latestTag.txt:', error);
}
EOF
        
        # Ejecutar el script de setTag directamente para generar los archivos
        node scripts/setTag.js
        
        # Verificar que los archivos se han creado correctamente
        echo "Contenido de .env:"
        cat .env
        
        echo "Contenido de public/env.js:"
        cat public/env.js || echo "El archivo public/env.js no existe"
        
        echo "Contenido de src/latestTag.txt:"
        cat src/latestTag.txt || echo "El archivo src/latestTag.txt no existe"
      displayName: 'Crear archivos de configuración con tag info'

    # Asegurarnos de que netlify no vuelva a construir la aplicación
    - script: |
        # Crear netlify.toml en la raíz
        echo "[build]" > netlify.toml
        echo "  publish = \"build\"" >> netlify.toml
        echo "  command = \"echo 'Site has been pre-built during Azure DevOps CI process'\"" >> netlify.toml
        cat netlify.toml
      displayName: 'Crear configuración de Netlify'

    # Instalar dependencias y construir la aplicación
    - script: |
        npm install
        REACT_APP_VERSION=$(deployTag) npm run build
      displayName: 'npm install and build'
      env:
        REACT_APP_VERSION: $(deployTag)
        REACT_APP_EMAILJS_PUBLIC_KEY: $(REACT_APP_EMAILJS_PUBLIC_KEY)
        REACT_APP_EMAILJS_SERVICE_ID: $(REACT_APP_EMAILJS_SERVICE_ID)
        REACT_APP_EMAILJS_TEMPLATE_ID: $(REACT_APP_EMAILJS_TEMPLATE_ID)

    # Copiar netlify.toml al directorio de build
    - script: |
        cp netlify.toml build/
      displayName: 'Copiar netlify.toml a build'

    # Archivar build
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/$(buildDir)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/build.zip'
        replaceExistingArchive: true
      displayName: 'Archive React build folder'

    # Publicar artefacto
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/build.zip'
        ArtifactName: 'drop'
        publishLocation: 'Container'
      displayName: 'Publish build artifact'

    # Desplegar a Netlify
    - script: |
        # Añadir información del tag al título del despliegue
        DEPLOY_TITLE="Deploy $(deployTag) from Azure DevOps"
        
        curl -X POST https://api.netlify.com/api/v1/sites/$(NETLIFY_SITE_ID)/deploys \
        -H "Authorization: Bearer $(NETLIFY_AUTH_TOKEN)" \
        -F "file=@$(Build.ArtifactStagingDirectory)/build.zip" \
        -F "title=$DEPLOY_TITLE"
      displayName: 'Deploy to Netlify'
      env:
        NETLIFY_AUTH_TOKEN: $(NETLIFY_AUTH_TOKEN)
        NETLIFY_SITE_ID: $(NETLIFY_SITE_ID)