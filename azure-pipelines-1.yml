trigger:
  branches:
    include:
      - main
#  tags:
#    include:
#      - V*

# Trigger para Pull Requests hacia main
pr:
- main

pool:
  name: Default

variables:
  buildDir: 'build'
  tagToUse: ''

stages:
- stage: Build_And_Deploy
  jobs:
  - job: GetLatestTag
    displayName: 'Obtener último tag'
    steps:
    - checkout: self
      fetchDepth: 0  # Obtiene todo el historial y tags
      
    - script: |
        # Obtener el último tag ordenado por fecha
        LATEST_TAG=$(git tag --sort=-committerdate | head -n 1)
        
        if [ -z "$LATEST_TAG" ]; then
          echo "##vso[task.logissue type=error]No se encontraron tags en el repositorio."
          exit 1
        fi
        
        echo "Último tag disponible: $LATEST_TAG"
        
        # Establecer variable para el siguiente job
        echo "##vso[task.setvariable variable=tagToUse;isOutput=true]$LATEST_TAG"
      displayName: 'Obtener último tag disponible'
      name: tagSelection

  - job: BuildAndDeploy
    dependsOn: GetLatestTag
    variables:
      deployTag: $[ dependencies.GetLatestTag.outputs['tagSelection.tagToUse'] ]
    steps:
    - checkout: self
      fetchDepth: 0
      clean: true
      
    - script: |
        # Verificar el tag que vamos a usar
        echo "Tag seleccionado para despliegue: $(deployTag)"
        
        # Verificar que el tag existe
        if ! git rev-parse "$(deployTag)" >/dev/null 2>&1; then
          echo "##vso[task.logissue type=error]El tag $(deployTag) no existe en el repositorio."
          echo "##[error]Tags disponibles:"
          git tag -l
          exit 1
        fi
        
        # Hacer checkout al tag seleccionado
        echo "Preparando despliegue del tag: $(deployTag)"
        git checkout $(deployTag)
        
        # Verificar que estamos en el tag correcto
        CURRENT_COMMIT=$(git rev-parse HEAD)
        TAG_COMMIT=$(git rev-parse $(deployTag))
        
        if [ "$CURRENT_COMMIT" != "$TAG_COMMIT" ]; then
          echo "##[error]No se pudo hacer checkout al tag $(deployTag)."
          exit 1
        fi
        
        echo "Checkout exitoso al tag $(deployTag) (commit: $CURRENT_COMMIT)"
      displayName: 'Checkout al tag seleccionado'
      
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Install Node.js'

    # PASO 1: Modificar el archivo App.js para reemplazar APP_VERSION con window.APP_VERSION
    - script: |
        echo "Modificando App.js para usar window.APP_VERSION..."
        
        # Verificar si App.js existe
        if [ ! -f "src/App.js" ]; then
            echo "##[error]El archivo src/App.js no existe."
            exit 1
        fi
        
        # Crear una copia de respaldo
        cp src/App.js src/App.js.bak
        
        # Reemplazar las instancias de APP_VERSION con window.APP_VERSION o appVersion
        sed -i 's/APP_VERSION/window.APP_VERSION/g' src/App.js
        
        echo "Archivo App.js modificado correctamente."
      displayName: 'Modificar App.js para usar window.APP_VERSION'
      continueOnError: true  # Continuar incluso si este paso falla

    # PASO 2: Crear archivos para almacenar la versión
    - script: |
        echo "Configurando archivos de versión con el tag: $(deployTag)"
        
        # Crear .env para Create React App
        echo "REACT_APP_VERSION=$(deployTag)" > .env
        
        # Crear src/version.js para importar en el código
        echo "export const APP_VERSION = '$(deployTag)';" > src/version.js
        
        # Crear env.js para inyectar en window
        mkdir -p public
        echo "// Auto-generado por Azure DevOps pipeline" > public/env.js
        echo "window.APP_VERSION = '$(deployTag)';" >> public/env.js
        
        # También crear latestTag.txt como respaldo
        echo "$(deployTag)" > src/latestTag.txt
        
        # Mostrar los archivos creados
        echo "Contenido de .env:"
        cat .env
        echo "Contenido de src/version.js:"
        cat src/version.js
        echo "Contenido de public/env.js:"
        cat public/env.js
        echo "Contenido de latestTag.txt:"
        cat src/latestTag.txt
      displayName: 'Crear archivos de versión'

    # PASO 3: Modificar el archivo index.html para incluir env.js
    - script: |
        echo "Modificando index.html para incluir env.js..."
        
        if [ -f "public/index.html" ]; then
            # Crear una copia de respaldo
            cp public/index.html public/index.html.bak
            
            # Verificar si ya contiene la referencia a env.js
            if grep -q "env.js" public/index.html; then
                echo "public/index.html ya incluye env.js, no es necesario modificarlo."
            else
                # Insertar la referencia antes de </head>
                sed -i 's#</head>#    <script src="%PUBLIC_URL%/env.js"></script>\n  </head>#' public/index.html
                echo "public/index.html modificado para incluir env.js."
            fi
        else
            echo "##[warning]El archivo public/index.html no existe. Creando uno nuevo."
            mkdir -p public
            cat > public/index.html << 'EOL'
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Portafolio de Rodrigo Montenegro - DevOps Engineer" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <script src="%PUBLIC_URL%/env.js"></script>
    <title>Rodrigo Montenegro | DevOps Engineer</title>
  </head>
  <body>
    <noscript>Necesitas habilitar JavaScript para ejecutar esta aplicación.</noscript>
    <div id="root"></div>
  </body>
</html>
EOL
            echo "Nuevo index.html creado con referencia a env.js."
        fi
      displayName: 'Modificar index.html para incluir env.js'

    # PASO 4: Crear archivo netlify.toml para evitar build en Netlify
    - script: |
        echo "Creando archivo netlify.toml..."
        cat > netlify.toml << 'EOL'
[build]
  publish = "build"
  command = "echo 'Sitio pre-construido en Azure DevOps - Omitiendo build en Netlify'"

[build.environment]
  NODE_VERSION = "18"
  NPM_VERSION = "9"
EOL
        echo "Archivo netlify.toml creado:"
        cat netlify.toml
      displayName: 'Crear archivo netlify.toml'

    # PASO 5: Instalar dependencias y construir
    - script: |
        npm install
      displayName: 'npm install'
      
    - script: |
        echo "Construyendo la aplicación con la versión $(deployTag)..."
        REACT_APP_VERSION="$(deployTag)" npm run build
      displayName: 'npm run build'
      env:
        REACT_APP_VERSION: $(deployTag)
        REACT_APP_EMAILJS_PUBLIC_KEY: $(REACT_APP_EMAILJS_PUBLIC_KEY)
        REACT_APP_EMAILJS_SERVICE_ID: $(REACT_APP_EMAILJS_SERVICE_ID)
        REACT_APP_EMAILJS_TEMPLATE_ID: $(REACT_APP_EMAILJS_TEMPLATE_ID)

    # PASO 6: Confirmar que netlify.toml esté en el directorio de build
    - script: |
        echo "Copiando netlify.toml al directorio de build..."
        cp netlify.toml build/
        
        # También copiar env.js para estar seguros
        echo "Confirmando que env.js está en el directorio de build..."
        if [ ! -f "build/env.js" ]; then
            cp public/env.js build/
        fi
        
        echo "Contenido del directorio de build:"
        ls -la build/
      displayName: 'Confirmar archivos en directorio de build'

    # PASO 7: Archivar build
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/$(buildDir)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/build.zip'
        replaceExistingArchive: true
      displayName: 'Archive React build folder'

    # PASO 8: Publicar artefacto
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/build.zip'
        ArtifactName: 'drop'
        publishLocation: 'Container'
      displayName: 'Publish build artifact'

    # PASO 9: Desplegar a Netlify
    - script: |
        # Añadir información del tag al título del despliegue
        DEPLOY_TITLE="Deploy $(deployTag) from Azure DevOps"
        
        echo "Desplegando a Netlify con título: $DEPLOY_TITLE"
        
        # Desplegar usando la API de Netlify
        curl -X POST https://api.netlify.com/api/v1/sites/$(NETLIFY_SITE_ID)/deploys \
        -H "Authorization: Bearer $(NETLIFY_AUTH_TOKEN)" \
        -F "file=@$(Build.ArtifactStagingDirectory)/build.zip" \
        -F "title=$DEPLOY_TITLE"
      displayName: 'Deploy to Netlify'
      env:
        NETLIFY_AUTH_TOKEN: $(NETLIFY_AUTH_TOKEN)
        NETLIFY_SITE_ID: $(NETLIFY_SITE_ID)